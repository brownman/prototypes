commander_test(){
    commander echo hi
}
commander_end(){
    commander $@
    commander flite -t finish
    pipe_translate finish
}
commander1(){
local str_caller="`caller`"
    local cmd_clip="gvim +${str_caller}"

    commander $@ 2>/tmp/err
    local res=$?
    test $res -eq 0 || $( gxmessage -file /tmp/err -entrytext "$cmd_clip" -title 'commander: Error' )
return $res
}
commander(){
    use_many indicator print trace
    local args=( $@ )
    local cmd="${args[@]}"
    print color 35 "[commander] $cmd"
local str_caller="`caller`"
    local cmd_clip="gvim +${str_caller}"


    echo "[ gvim +${str_caller} ] $cmd" >> /tmp/trace
    eval "$cmd" 

    local res="$?"
    indicator $res
    return $res
}
commander_n(){
    local args=( $@ )
    local cmd="${args[@]}"
    printn color 35 "[commander] $cmd"
    #setting e + 
    echo "$cmd" >> /tmp/trace
    #eval "$cmd"
    $cmd
    local res="$?"
    indicator $res
    return $res
}
commander_lock_file(){

    print func
    local file=${1:-$0}

    print color 33 allow only 1 instance of this command
    naming $file
    locking $file

    trap unlocking SIGTERM
    trap unlocking SIGINT
    trap unlocking EXIT
    if [ $# -gt 1 ];then

        shift
        local args=( $@ )
        local cmd="${args[@]:-}"
        commander "bash -c $file $cmd" 
    else
        commander "bash -c $file"
    fi
    #commander unlocking
}
commander2(){
    local args=( $@ ) 
    local cmd="${args[@]}"
    commander "$cmd" || ( print error "$cmd" ; sleep 10; )
}
export -f commander
export -f commander_n
export -f commander_lock_file
export -f commander1
